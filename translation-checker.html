<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reikoku Translation Checker</title>
  <style>
    body { display: flex; flex-direction: column; font-family: monospace; margin: 0; padding: 0; height: 100vh; }
    .container { display: flex; flex: 1; overflow: hidden; }
    .pane { display: flex; flex-direction: column; padding: 10px; box-sizing: border-box; overflow: hidden; background-color: #f6fbff;}
    textarea { flex: 1; resize: none; font-family: monospace; }
    .controls {display: flex; flex-wrap: wrap; gap: 8px;  margin-top: 10px;
    
    font-size: 0.85rem; padding: 4px; border: 1px solid #aaa; border-radius: 4px; background-color: #ffffff;
  
  }
    .controls label { display: flex; flex-direction: column; font-size: 0.9rem; background-color: #eafcff;
    border: 1px solid;
    border-radius: 3px;
    padding: 4px;
	}
  .controls-container { display: flex; gap: 10px; justify-content: center;}

  .controls-presets {margin-top: 0; width: -webkit-fill-available;}

  .controls-presets label {flex: 1;}

    .outputs { display: flex; gap: 10px; flex: 1; overflow: auto; margin-top: 10px;}
    .output { flex: 1; border: 1px solid #333; padding: 5px; box-sizing: border-box; overflow: auto; background-color: #f7f7f7;}
    .stats-container { display: flex; gap: 10px; margin-top: 10px; }
    .stats { font-size: 0.85rem; color: #555; padding: 4px; border: 1px solid #aaa; border-radius: 4px; flex: 1; background-color: #ffffff;}
    .stats div { margin-bottom: 4px; }
    .window-wrapper { margin-bottom: 8px; }
    .sentence-label { font-size: 0.75rem; color: #333; margin-bottom: 2px; }
    .window { border: 1px solid #666; overflow: hidden; width: fit-content; min-width: max-content; background-color: #ffffff;} 
    .empty-window { visibility: hidden; }
    .frame { padding: 4px; box-sizing: border-box; width: fit-content; }
    .char { display: inline-block; text-align: center; box-sizing: border-box; line-height: 1; vertical-align: top; }
    .divider {
      width: 5px;
      background: #ccc;
      cursor: ew-resize;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .divider::before {
      content: '⋮';
      font-size: 26px;
      color: #888;
      writing-mode: vertical-lr;
      transform: rotate(90deg);
      pointer-events: none;
      margin-bottom: 45px;
    }
    .sentence-num {
        font-size: 0.75rem;
        padding-bottom: 2px;
        user-select: none;
        width: fit-content;
    }
    .sentence-num:not(:first-child) {
      margin-top: 8px;
    }
    .sentence-num:hover {
        color: rgb(121, 121, 252);
        font-weight: bold;
    }

    .sentence-num.highlight {
      color: rgb(121, 121, 252);
      font-weight: bold; 
    }

    .char {
      display: inline-flex;       
      justify-content: center;   
      align-items: center;        
      width: 16px;                
      height: 20px;              
      font-size: 14px;           
      line-height: 1;             
      font-family: monospace;
    }

    .frame div {
        display: flex;
    }

    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
      border-bottom: 1px solid #0400ff47;
    }

    .tooltip .tooltip-text {
      visibility: hidden;
      background-color: #333;
      color: #fff;
      font-size: 12px;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 10;
      bottom: 125%;
      left: 0;
      width: max-content;
      max-width: 220px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

</style>
</head>
<body>

  <div class="container">
    <div id="leftPane" class="pane" style="flex: 1;">

      <!-- Original script -->
      <div style="display: flex; justify-content: space-between;">
        <h3>Original Script</h3>
        <div style="display: flex; align-items: center;"> 
          <p>Keywords List:</p>
          <button class="toggleKeywordsBtn" data-target="keywordContainerOriginal" style="margin-left: 5px;">Show</button>
        </div>
      </div>
      <div id="keywordContainerOriginal" style="display:none; margin-bottom: 10px; margin-left: auto;">
        <textarea id="keywordDictOriginal" rows="10" cols="40" placeholder="Enter keywords list, one per line">
アヴァダーナ[END]
悪魔の苗領[END]
アダムとイブ[END]
アニミズム[END]
アヌビス[END]
阿募[END]
アブダクション[END]
アフラ・マズダ[END]
アブラハム[END]
アミティヴィル[END]
アムシャ・スプンタ[END]
アメミット[END]
アンリ・マンユ[END]
インセンス[END]
インドラ[END]
ヴィシュヌ[END]
氏神[END]
ウロボロスの蛇[END]
オージン[END]
オシリス[END]
陰陽五行の祖生と祖剋[END]
陰陽道[END]
カイン[END]
型霊[END]
カバラ[END]
観測者効果[END]
叫喚[END]
教令輪身[END]
巨人族[END]
結跏趺坐[END]
ゲルグ旅[END]
ゲルマン人やノルマン人[END]
高野山[END]
累縄[END]
蠱毒[END]
胡粉[END]
御幣[END]
全剛界[END]
シヴァ[END]
四国八十八ヶ所[END]
使徒[END]
ジプシー[END]
下総国豊田郡[END]
シャーリー・マクレーン[END]
衆合[END]
巡行透视[END]
浄土真宗[END]
焦熱[END]
人智学[END]
スェデンボルイ[END]
スフィンクスの前脚の問の害字板[END]
セラピー[END]
大叫喚[END]
大焦熱[END]
胎蔵界[END]
ダンテの『神曲』[END]
竿浴[END]
トーテム[END]
ニューエイジ[END]
涅槃[END]
ノアの箱舟[END]
八卦[END]
バベルの塔[END]
バラモン教[END]
ブラフマー[END]
プロテスタント[END]
忘却の川[END]
ボシュ[END]
善提心[END]
マナス界[END]
禊[END]
メスメリスト[END]
メンタル体[END]
ヤザタ[END]
ヤマ天[END]
ヨガ[END]
ヨセフ[END]
ヨハネ[END]
六道[END]
録全術[END]
脇侍[END]
ワルハラ[END]
        </textarea><br>
      </div>
      <textarea id="inputScript" placeholder="Enter original script..."></textarea>

      <!-- Translation script -->
      <div style="display: flex; justify-content: space-between; ">
        <h3>Translation</h3>
        <div style="display: flex; align-items: center;"> 
          <p>Keywords List:</p>
          <button class="toggleKeywordsBtn" data-target="keywordContainerTranslated" style="margin-left: 5px;">Show</button>
        </div>
      </div>
      <div id="keywordContainerTranslated" style="display:none; margin-bottom: 10px; margin-left: auto;">
        <textarea id="keywordDictTranslated" rows="10" cols="40" placeholder="Enter keywords list, one per line"></textarea><br>
      </div>
      <textarea id="translatedScript" placeholder="Enter translated script..."></textarea>
      
      <div class="controls">
        <label>Font Size (px):<input type="number" id="charFont" value="16" min="1"></label>
        <label>Char Height (px):<input type="number" id="charHeight" value="20" min="1"></label>
        <label>Auto-render<input type="checkbox" id="autoRender" checked></label>
        <label>Auto-align sentences<input type="checkbox" id="autoAlign" checked></label>
        <label>Sync Scroll<input type="checkbox" id="syncScrollCheck" checked></label>
        <button id="renderBtn" style="margin-left: auto; padding: 5px 15px;">Render</button>
      </div>
    </div>
    <div id="divider" class="divider"></div>
    <div id="rightPane" class="pane" style="flex: 1;">
      <div style="display: flex; justify-content: space-around;">
        <h3>Original</h3>
        <h3>Translation</h3>
      </div>
      <div class="controls-container" id="controlsContainer">
        <!-- Original -->
        <div class="controls controls-presets original-preset">
          <label>Original Preset:
            <select id="presetSizeOriginal">
              <option value="dial1">Dialogue</option>
              <option value="dial2">High Dialogue</option>
              <option value="db" selected>Database</option>
			        <option value="note">Note</option>
              <option value="custom">Custom</option>
          </select>
          </label>
          <label>Width (chars):<input type="number" id="widthCharsOriginal" value="19" min="1"></label>
          <label>Height (lines):<input type="number" id="heightLinesOriginal" value="3" min="1"></label>
          <label>Char Width (px):<input type="number" id="charWidthOriginal" value="18" min="1"></label>
        </div>
      
        <!-- Translated -->
        <div class="controls controls-presets transition-preset">
          <label>Translation Preset:
            <select id="presetSizeTranslated">
              <option value="dial1fix">Dialogue</option>
              <option value="dial2fix">High Dialogue</option>
              <option value="dbfix" selected>Database</option>
			        <option value="notefix">Note</option>
              <option value="custom">Custom</option>
            </select>
          </label>
          <label>Width (chars):<input type="number" id="widthCharsTranslated" value="33" min="1"></label>
          <label>Height (lines):<input type="number" id="heightLinesTranslated" value="3" min="1"></label>
          <label>Char Width (px):<input type="number" id="charWidthTranslated" value="9" min="1"></label>
        </div>
      </div>
      <div class="outputs">
        <div class="output" id="outputOriginal"></div>
        <div class="output" id="outputTranslated"></div>
      </div>
      <div class="stats-container" id="statsContainer"></div>
    </div>
  </div>
<script>


  // Show/Hide switcher
  function toggleContainer(targetId, btn) {
    const container = document.getElementById(targetId);
    if (container.style.display === 'none' || container.style.display === '') {
      container.style.display = 'block';
      btn.textContent = 'Hide';
    } else {
      container.style.display = 'none';
      btn.textContent = 'Show';
    }
  }

  // Show/Hide handler
  document.querySelectorAll('.toggleKeywordsBtn').forEach(btn => {
    btn.addEventListener('click', () => {
      toggleContainer(btn.dataset.target, btn);
    });
  });

  const keywordMap = {1: 99, 2: 83, 3: 119, 4: 117, 5: 85, 6: 161, 7: 128, 8: 162, 9: 141, 10: 111, 11: 91, 13: 90, 14: 110, 15: 149, 16: 89, 17: 116, 18: 153, 19: 159, 20: 96, 21: 95, 22: 84, 23: 157, 24: 100, 25: 138, 26: 104, 27: 124, 28: 106, 29: 112, 31: 152, 32: 163, 33: 109, 34: 156, 35: 97, 36: 102, 37: 132, 38: 147, 39: 113, 40: 107, 42: 98, 43: 86, 44: 120, 45: 93, 46: 101, 47: 121, 48: 136, 49: 92, 50: 125, 51: 127, 52: 130, 53: 131, 54: 143, 55: 88, 56: 137, 57: 115, 58: 150, 59: 155, 60: 103, 61: 118, 62: 139, 63: 82, 64: 148, 65: 122, 66: 105, 67: 145, 68: 154, 69: 158, 70: 123, 72: 134, 73: 129, 74: 133, 75: 126, 76: 160, 77: 144, 78: 142, 79: 140, 80: 151, 81: 94};

  // Get keywords list
  function getKeywordsDict(textareaId) {
    const raw = document.getElementById(textareaId).value.trim();
    
    if (!raw) return {};

    const lines = raw.split('\n').map(line => line.trim()).filter(Boolean);
    const dict = {};

    let i = 0;
    for (let line of lines) {
      const val = keywordMap[i];
      if (val !== undefined) {
        const key = `(${i},0,${val})`;
        line = line.replace(/\[END\]/g, '');
        dict[key] = line;
      }
      i++;
    }

    return dict;
  }

let keywordDictOriginal = getKeywordsDict('keywordDictOriginal');
let keywordDictTranslated = getKeywordsDict('keywordDictTranslated');

document.getElementById('keywordDictOriginal').addEventListener('input', e => {
  keywordDictOriginal = getKeywordsDict('keywordDictOriginal');
});

document.getElementById('keywordDictTranslated').addEventListener('input', e => {
  keywordDictTranslated = getKeywordsDict('keywordDictTranslated');
});

const divider = document.getElementById('divider');
const leftPane = document.getElementById('leftPane');
const rightPane = document.getElementById('rightPane');
let isDragging = false;

divider.addEventListener('mousedown', e => { isDragging = true; document.body.style.cursor = 'ew-resize'; });
document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const rect = document.querySelector('.container').getBoundingClientRect();
  let x = e.clientX - rect.left;
  const min = 100, max = rect.width - min;
  x = Math.min(Math.max(x, min), max);
  leftPane.style.flex = `0 0 ${x}px`;
});
document.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; document.body.style.cursor = ''; } });

function countCommands(text, cmd) {
  const regex = cmd.includes(':')
    ? new RegExp(`\\[${cmd.replace(':', ':.*?')}\\]`, 'g')   // commands with params
    : new RegExp(`\\[${cmd}\\]`, 'g');                       // regular commands
  return (text.match(regex) || []).length;
}

const colorPalette = {
  0: '#000000',  // black
  1: '#FFFFFF',  // white
  2: '#FF0000',  // red
  3: '#00FF00',  // green
  4: '#00FFFF',  // cyan
  5: '#FFFF00',  // yellow
  6: '#0000FF',  // blue
  7: '#FF00FF',  // magenta
  8: '#888888',
  9: '#444444',
  10: '#AAAAAA',
  11: '#880000',
  12: '#008800',
  13: '#000088',
  14: '#888800',
  15: '#008888'
};

function parseScript(text, keywordDict, foldedBreaks = false) {
  let tokens = [], i = 0;
  let lastWasNewline = false;
  let currentColor = 0;
  let underline = false;

  while (i < text.length) {
    if (text[i] === '[') {
      const slice = text.slice(i);
	
	  if (/^\[RAW:[^\]]+\]/.test(slice)) {
        const match = slice.match(/^\[RAW:[^\]]+\]/);
        i += match[0].length;
        continue;
      }
	  
	  if (/^\[DELAY:[^\]]+\]/.test(slice)) {
        const match = slice.match(/^\[DELAY:[^\]]+\]/);
        i += match[0].length;
        continue;
      }
	  
	  if (/^\[FUNC_ID:[^\]]+\]/.test(slice)) {
        const match = slice.match(/^\[FUNC_ID:[^\]]+\]/);
        i += match[0].length;
        continue;
      }
	  
	  if (/^\[FUNC_ADR:[^\]]+\]/.test(slice)) {
        const match = slice.match(/^\[FUNC_ADR:[^\]]+\]/);
        i += match[0].length;
        continue;
      }
	  
      if (/^\[CLUT:(\d+)\]/.test(slice)) {
        const match = slice.match(/^\[CLUT:(\d+)\]/);
        currentColor = +match[1];
        tokens.push(`{CLUT:${currentColor}}`);
        i += match[0].length;
        continue;
      }

      if (/^\[IMG:\(([^)]+)\)\]/.test(slice)) {
        i += slice.match(/^\[IMG:\(([^)]+)\)\]/)[0].length;
        continue; // ignore image
      }

      if (/^\[KEYWORD:\(([^)]+)\)\]/.test(slice)) {
        const match = slice.match(/^\[KEYWORD:\(([^)]+)\)\]/);
        const key = `(${match[1]})`;
        tokens.push(keywordDict[key] || '??KEYWORD??');
        i += match[0].length;
        continue;
      }

      if (/^\[END_PAGE\]/.test(slice)) {
        tokens.push('{END_PAGE}');
        i += '[END_PAGE]'.length;
        continue;
      }

      if (/^\[LINE\]/.test(slice)) {
        underline = !underline;
        tokens.push(`{LINE:${underline ? 1 : 0}}`);
        i += '[LINE]'.length;
        continue;
      }

      if (/^\[WAIT_1\]/.test(slice)) {
        if (!lastWasNewline) {
          tokens.push('\n');
          lastWasNewline = true;
        }
        i += '[WAIT_1]'.length;
        continue;
      }

      if (/^\[SP:(\d+)\]/.test(slice)) {
        const match = slice.match(/^\[SP:(\d+)\]/);
        tokens.push(' '.repeat(+match[1]));
        i += match[0].length;
        continue;
      }

      if (/^\[(DELAY|WAIT_2|)\]/.test(slice)) {
        i += slice.match(/^\[(DELAY|WAIT_2)\]/)[0].length;
        continue;
      }

      if (/^\[CLEAR\]/.test(slice)) {
        tokens.push('{CLEAR}');
        i += '[CLEAR]'.length;
        continue;
      }

      if (/^\[INDENT\]/.test(slice)) {
        tokens.push('{INDENT}');
        i += '[INDENT]'.length;
        continue;
      }

      if (/^\[END\]/.test(slice)) {
        tokens.push('{END}');
        i += '[END]'.length;
        continue;
      }
    }

    if (text[i] === '\\' && text[i + 1] === 'n') {
      if (foldedBreaks || !lastWasNewline) {
        tokens.push('\n');
        lastWasNewline = true;
      }
      i += 2;
    } else {
      if (text[i] !== '\n' && text[i] !== '\r') lastWasNewline = false;
      tokens.push(text[i]);
      i++;
    }
  }

  return tokens.join('');
}

function buildWindows(parsed, width, height) {
  const windows = [];
  let lines = [[]];
  let indent = 0;
  let currentColor = 0;
  let underline = false;

  function flushWindow() {
  // 1) скопировать накопленные строки
  let win = lines.map(line => line.slice());

  // 2) убрать ВСЕ trailing-пустые строки
  while (
    win.length > 0 &&
    win[win.length - 1].every(cell => cell.ch.trim() === '')
  ) {
    win.pop();
  }

  // 3) «жёстко» дополнить до заданной высоты
  while (win.length < height) {
    win.push([]);  // добавляем полностью пустую строку
  }

  // 4) затем в каждую строку заполняем пробелами до ширины
  win = win.map(line => {
    while (line.length < width) {
      line.push({ ch: ' ', color: currentColor, underline });
    }
    return line;
  });

  // 5) сохранить окно, если в нём есть хоть один непустой символ
  if (win.some(row => row.some(cell => cell.ch.trim() !== ''))) {
    windows.push(win);
  }

  // 6) начать новый буфер строк
  lines = [[]];
}


  for (let i = 0; i < parsed.length;) {
    if (parsed.startsWith('{CLEAR}', i) || parsed.startsWith('{END}', i) || parsed.startsWith('{END_PAGE}', i)) {
      flushWindow();
      let skip = 0;
      if (parsed.startsWith('{CLEAR}', i)) skip = 7;
      else if (parsed.startsWith('{END}', i)) skip = 5;
      else if (parsed.startsWith('{END_PAGE}', i)) skip = 10;
      i += skip;
      continue;
    }

    if (parsed.startsWith('{CLUT:', i)) {
      const match = parsed.slice(i).match(/^\{CLUT:(\d+)\}/);
      currentColor = +match[1];
      i += match[0].length;
      continue;
    }

    if (parsed.startsWith('{LINE:', i)) {
      underline = parsed[i + 6] === '1';
      i += 8;
      continue;
    }

    if (parsed.startsWith('{INDENT}', i)) {
      indent = lines[lines.length - 1].length;
      i += 8;
      continue;
    }

    if (parsed[i] === '\n') {
  // если текущая строка пуста — пропускаем символ перевода строки
  const currentLine = lines[lines.length - 1];
  if (currentLine.length === 0) {
    i++; // просто пропускаем \n
    continue;
  }

  // иначе — нормальная логика переноса строки
  i++;
  lines.push([]);

  // проверка на переполнение окна
  if (lines.length >= height + 1) {
    flushWindow();
  } else {
    // добавляем отступ, только если НЕ начали новое окно
    for (let j = 0; j < indent; j++) {
      lines[lines.length - 1].push({ ch: ' ', color: currentColor, underline });
    }
  }

  continue;
}

    const ch = parsed[i++];
    let line = lines[lines.length - 1];
    if (line.length >= width) {
      const newLine = [];
      for (let j = 0; j < indent; j++) {
        newLine.push({ ch: ' ', color: currentColor, underline });
      }
      lines.push(newLine);
      line = lines[lines.length - 1];
    }

    line.push({ ch, color: currentColor, underline });

    if (lines.length === height && line.length === width) {
      flushWindow();
    }
  }

  if (lines.some(row => row.some(cell => cell.ch.trim() !== ''))) {
    flushWindow();
  }

  return windows;
}




function analyze(raw, parsed, windows, width, height) {
  const totalParsedChars = parsed.replace(/\{.*?\}/g, '').length;
  const occupancy = windows.reduce((sum, w) => sum + w.join('').trim().length, 0);
  const capacity = windows.length * width * height;
  return {
    windowCount: windows.length,
    commandsEnd: countCommands(raw, 'END'),
    commandsSpace: countCommands(raw, 'SP:'),

    commandsClear: countCommands(raw, 'CLEAR'),
    commandsIndent: countCommands(raw, 'INDENT'),
    commandsWait1: countCommands(raw, 'WAIT_1'),
    commandsWait2: countCommands(raw, 'WAIT_2'),
    commandsDelay: countCommands(raw, 'DELAY:'),
    commandsFuncID: countCommands(raw, 'FUNC_ID:'),
    commandsFuncAdr: countCommands(raw, 'FUNC_ADR:'),
    commandsRaw: countCommands(raw, 'RAW:'),

    commandsEndPage: countCommands(raw, 'END_PAGE'),
    commandsKeyword: countCommands(raw, 'KEYWORD:'),
    commandsImg: countCommands(raw, 'IMG:'),
    commandsClut: countCommands(raw, 'CLUT:'),
    commandsLine: countCommands(raw, 'LINE'),

    occupancy, capacity,
    dims: `${width}×${height}`
  };
}

function renderPreview(textId, outId, width, height, foldedBreaks, charW, charH, charF, keywordDict) {
  const raw = document.getElementById(textId).value;
  const cleanedRaw = raw.replace(/(?<!\\)\\n|\n/g, match => {
    if (match === '\n') return '';
    return match;
  });
  const parsed = parseScript(cleanedRaw, keywordDict, foldedBreaks);
  const windows = buildWindows(parsed, width, height);
  const stats = analyze(cleanedRaw, parsed, windows, width, height);

  const out = document.getElementById(outId);
  out.innerHTML = '';

  let sentenceIndex = 1;
  let windowSentenceIndexes = [];
  
  const endSplit = cleanedRaw.split(/\[(?:END|END_PAGE)\]/g);
  endSplit.forEach(segment => {
    const parsedSegment = parseScript(segment, keywordDict, foldedBreaks);
    const segmentWins = buildWindows(parsedSegment, width, height);
    for (let i = 0; i < segmentWins.length; i++) {
      windowSentenceIndexes.push(sentenceIndex);
    }
    sentenceIndex++;
  });

  let lastLabel = null;
  windows.forEach((lines, i) => {
    const sentenceNum = windowSentenceIndexes[i];
    const winDiv = document.createElement('div');
    winDiv.className = 'window';

    if (sentenceNum !== lastLabel) {
      const label = document.createElement('div');
      label.className = "sentence-num";
      label.textContent = `Sentence ${sentenceNum}`;
      out.appendChild(label);
      lastLabel = sentenceNum;
    }

    const frame = document.createElement('div');
    frame.className = 'frame';
    lines.forEach(rowData => {
      const row = document.createElement('div');
      rowData.forEach(cell => {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = cell.ch;
        span.style.width = charW + 'px';
        span.style.height = charH + 'px';
        span.style.fontSize = charF + 'px';
        span.style.color = colorPalette[cell.color] || '#000';
        if (cell.underline) {
          span.style.textDecoration = 'underline';
          span.style.textUnderlineOffset = '4px';
        };
        row.appendChild(span);
      });
      frame.appendChild(row);
    });
    winDiv.appendChild(frame);
    out.appendChild(winDiv);
    stats.sentences = sentenceNum;
  });

  return stats;
}


function renderStats(statsArr) {
  const container = document.getElementById('statsContainer');
  container.innerHTML = '';

  const [original, translation] = statsArr;

  const commandKeys = [
    ['commandsEnd', '[END]'],
    ['commandsSpace', '[SP]'],

    ['commandsClear', '[CLEAR]'],
    ['commandsIndent', '[INDENT]'],
    ['commandsWait1', '[WAIT_1]'],
    ['commandsWait2', '[WAIT_2]'],
    ['commandsDelay', '[DELAY]'],
    ['commandsFuncID', '[FUNC_ID]'],
    ['commandsFuncAdr', '[FUNC_ADR]'],
    ['commandsRaw', '[RAW]'],

    ['commandsEndPage', '[END_PAGE]'],
    ['commandsKeyword', '[KEYWORD]'],
    ['commandsClut', '[CLUT]'],
    ['commandsLine', '[LINE]'],
    ['commandsImg', '[IMG]'],
  ];

  statsArr.forEach((s, i) => {
    const box = document.createElement('div');
    box.className = 'stats';

    const isOriginal = i === 0;
    const counterpart = isOriginal ? translation : original;

    const commandHTML = commandKeys.map(([key, label]) => {
      const count = s[key];
      const otherCount = counterpart[key];
      let color;
      if (count === 0 && otherCount === 0) {
        color = '#959595';
      } else if (count === otherCount) {
        color = 'blue';
      } else if (count > otherCount) {
        color = 'green';
      } else if (count < otherCount) {
        color = 'red';
      }
      return `<span style="color: ${color}">${label}×${count}</span>`;
    }).join(', ');
    box.innerHTML = `
<div><b>Windows:</b> ${s.windowCount}, <b>Sentences</b>: ${s.sentences ? s.sentences : 0}</div>
<div class="tooltip">
  <b>Commands entries:</b>
  <div class="tooltip-text">
    General:<br>
    [END] — End of entry<br>
    [SP:XX] — Consecutive spaces<br>
    <br>
    Dialogue:<br>
    [CLEAR] — Clear Window<br>
    [INDENT] — Sets the indentation from current pos<br>
    [WAIT_1] — Wait for input and continue with a new line<br>
    [WAIT_2] — Wait for input<br>
    [DELAY:XX] — Delay before withdrawal, 60 (~1 second)<br>
    <br>
    Database / Note:<br>
    [END_PAGE] — End of page entry<br>
    [KEYWORD:XX] — Inserts a keyword from the dictionary<br>
    [CLUT:XX] — Сhanges color for all following characters<br>
    [LINE] — Switch underline for all following characters<br>
    <br>
    ... — are just skipped
  </div>
</div>
<div>${commandHTML}</div>
`;

    container.appendChild(box);
  });
}

function syncScroll(e) {
  if (!document.getElementById('syncScrollCheck').checked) {
    return;
  }
  if (isSyncingScroll) return;
  isSyncingScroll = true;

  const source = e.target;
  const target = source === outputOriginal ? outputTranslated : outputOriginal;

  // Source scroll percentage (0..1)
  const scrollPercent = source.scrollTop / (source.scrollHeight - source.clientHeight);

  // Set the target scrolling to the same percentage
  target.scrollTop = scrollPercent * (target.scrollHeight - target.clientHeight);

  isSyncingScroll = false;
}

function getSentencePositions(text) {
  const positions = [];
  const regexEnd = /\[(?:END|END_PAGE)\]/g;
  let lastIndex = 0;
  positions.push(findRealStart(text, 0)); // beginning of the first sentence

  let match;
  while ((match = regexEnd.exec(text)) !== null) {
    // the beginning of the next sentence is after [END]
    const nextStart = match.index + match[0].length;
    if (nextStart < text.length) {
      positions.push(findRealStart(text, nextStart));
    }
    lastIndex = match.index;
  }

  return positions;

  // A helper function that looks for the real beginning of a sentence,
  // omitting [CLEAR], [RAW:*], \n and other commands at the beginning
  function findRealStart(text, pos) {
    let i = pos;
    while (i < text.length) {
      // If a command in the format [COMMAND] is encountered, skip it completely
      if (text[i] === '[') {
        const m = text.slice(i).match(/^\[([A-Z_0-9:]+)\]/);
        if (m) {
          i += m[0].length;
          continue;
        }
      }
      // Skip line breaks \n and spaces at the beginning
      if (text[i] === '\\' && text[i + 1] === 'n') { i += 2; continue; }
      if (text[i] === '\n' || text[i] === ' ' || text[i] === '\r' || text[i] === '\t') { i++; continue; }

      // The first "real" character of the text is the position for the cursor
      break;
    }
    return i;
  }
}

function scrollToSentence(textarea, pos) {
  const value = textarea.value;

  // Найти конец предложения ([END] или [END_PAGE])
  const endMatch = value.slice(pos).match(/\[(END|END_PAGE)\]/);
  const end = endMatch ? pos + endMatch.index + endMatch[0].length : value.length;

  // Очистка лишних служебных тегов
  let start = pos;
  while (start < end) {
    if (value[start] === '[') {
      const cmdMatch = value.slice(start).match(/^\[([A-Z_0-9:]+)\]/);
      if (cmdMatch) {
        start += cmdMatch[0].length;
        continue;
      }
    }
    if (value[start] === '\\' && value[start + 1] === 'n') {
      start += 2;
      continue;
    }
    if ([' ', '\n', '\r', '\t'].includes(value[start])) {
      start++;
      continue;
    }
    break;
  }

  // Устанавливаем выделение
  textarea.focus();
  textarea.setSelectionRange(start, end);

  // Скроллим: расчёт scrollTop по пропорции позиции в общем тексте
  const totalLength = value.length;
  const scrollRatio = start / totalLength;
  const scrollTop = scrollRatio * textarea.scrollHeight - textarea.clientHeight / 2;

  textarea.scrollTop = Math.max(0, scrollTop);
}




function attachClickHandlers(width, height) {
  const inputTextarea = document.getElementById('inputScript');
  const translatedTextarea = document.getElementById('translatedScript');

  const sentencePositionsOriginal = getSentencePositions(inputTextarea.value);
  const sentencePositionsTranslated = getSentencePositions(translatedTextarea.value);

  const outputOriginal = document.getElementById('outputOriginal');
  const outputTranslated = document.getElementById('outputTranslated');

  function getSentenceNumFromElement(el) {
    let target = el;
    // If it is a window, we look for the previous element with the sentence number
    if (el.classList.contains('window')) {
      target = el.previousElementSibling;
      while (target && !target.classList.contains('sentence-num')) {
        target = target.previousElementSibling;
      }
    }
    if (target && target.classList.contains('sentence-num')) {
      const match = target.textContent.match(/Sentence (\d+)/);
      if (match) {
        return parseInt(match[1], 10);
      }
    }
    return null;
  }

  function handleClick(el) {
    const num = getSentenceNumFromElement(el);
    if (num === null) return;

    // We determine which block was clicked - the original or the translation
    const isOriginal = el.closest('#outputOriginal') !== null;

    // First, select in another textarea (without focus)
    if (num > 0 && num <= sentencePositionsOriginal.length && !isOriginal) {
      scrollToSentence(inputTextarea, sentencePositionsOriginal[num - 1]);
    }
    if (num > 0 && num <= sentencePositionsTranslated.length && isOriginal) {
      scrollToSentence(translatedTextarea, sentencePositionsTranslated[num - 1]);
    }

    // Then we select in the textarea where the click was (with focus)
    if (num > 0 && num <= sentencePositionsOriginal.length && isOriginal) {
      scrollToSentence(inputTextarea, sentencePositionsOriginal[num - 1]);
    }
    if (num > 0 && num <= sentencePositionsTranslated.length && !isOriginal) {
      scrollToSentence(translatedTextarea, sentencePositionsTranslated[num - 1]);
    }
  }

  // We attach handlers to both blocks - for the original and for the translation
  [outputOriginal, outputTranslated].forEach(container => {
    container.querySelectorAll('.sentence-num, .window').forEach(el => {
      el.style.cursor = 'pointer';
      el.onclick = () => handleClick(el);
    });
  });
}

function getPresetDimensions(type) {
  const presetId = `presetSize${type}`;
  const widthId = `widthChars${type}`;
  const heightId = `heightLines${type}`;
  const charWidthId = `charWidth${type}`;
  
  const preset = document.getElementById(presetId).value;
  let width, height, charWidth, foldedBreaks;

  foldedBreaks = false;
  if (presetId === 'presetSizeOriginal') charWidth = 18;
  if (presetId === 'presetSizeTranslated') charWidth = 9;

  if (preset === 'dial1') {
    width = 19;
    height = 3;
  } else if (preset === 'dial2') {
    width = 19;
    height = 12;
  } else if (preset === 'dial1fix') {
    width = 33;
    height = 3;
    charWidth = 10;
  } else if (preset === 'dial2fix') {
    width = 33;
    height = 12;
    charWidth = 10;
  } else if (preset === 'db') {
    width = 19;
    height = 10;
    foldedBreaks = true;
  } else if (preset === 'dbfix') {
    width = 29;
    height = 10;
    foldedBreaks = true;
    charWidth = 11;
  } else if (preset === 'note') {
    width = 19;
    height = 5;
    foldedBreaks = true;
  } else if (preset === 'notefix') {
    width = 29;
    height = 5;
    foldedBreaks = true;
    charWidth = 11;
  } else if (preset !== 'custom') {
    [width, height] = preset.split('x').map(n => +n);
  } else {
    width = +document.getElementById(widthId).value;
    height = +document.getElementById(heightId).value;
    charWidth = +document.getElementById(charWidthId).value;
  }
  
  // Update the UI with resolved values
  document.getElementById(widthId).value = width;
  document.getElementById(heightId).value = height;
  document.getElementById(charWidthId).value = charWidth;

  return { width, height, charWidth, foldedBreaks };
}

function attachHoverHandlers() {
  const outputOriginal = document.getElementById('outputOriginal');
  const outputTranslated = document.getElementById('outputTranslated');

  function addHoverEvents(container) {
    container.querySelectorAll('.window').forEach(win => {
      win.addEventListener('mouseenter', () => {
        let prev = win.previousElementSibling;
        while (prev && !prev.classList.contains('sentence-num')) prev = prev.previousElementSibling;
        if (prev) prev.classList.add('highlight');
      });
      win.addEventListener('mouseleave', () => {
        let prev = win.previousElementSibling;
        while (prev && !prev.classList.contains('sentence-num')) prev = prev.previousElementSibling;
        if (prev) prev.classList.remove('highlight');
      });
    });
  }

  addHoverEvents(outputOriginal);
  addHoverEvents(outputTranslated);
}

function render() {
  const { width: wO, height: hO, charWidth: cwO, foldedBreaks: fbO } = getPresetDimensions('Original');
  const { width: wT, height: hT, charWidth: cwT, foldedBreaks: fbT } = getPresetDimensions('Translated');
  const charH = +document.getElementById('charHeight').value;
  const charF = +document.getElementById('charFont').value;

  const statsIn = renderPreview('inputScript', 'outputOriginal', wO, hO, fbO, cwO, charH, charF, keywordDictOriginal);
  const statsTr = renderPreview('translatedScript', 'outputTranslated', wT, hT, fbT, cwT, charH, charF, keywordDictTranslated);
  
  renderStats([statsIn, statsTr]);

  attachClickHandlers(wO, hO);
  attachHoverHandlers();

  if (document.getElementById('autoAlign').checked) {
    alignSentenceWindows(wO, hO, cwO, charH);
  }
}

function alignSentenceWindows(width, height, charWidth, charH) {
  const origContainer = document.getElementById('outputOriginal');
  const transContainer = document.getElementById('outputTranslated');

  // We collect for the container: map { sentenceNum → { label, windows: [div.window...] } }
  function groupBySentence(container) {
    const map = new Map();
    let current = null;
    container.childNodes.forEach(node => {
      if (node.classList && node.classList.contains('sentence-num')) {
        const num = parseInt(node.textContent.match(/Sentence (\d+)/)[1], 10);
        map.set(num, { label: node, windows: [] });
        current = num;
      } else if (node.classList && node.classList.contains('window') && current !== null) {
        map.get(current).windows.push(node);
      }
    });
    return map;
  }

  const origMap = groupBySentence(origContainer);
  const transMap = groupBySentence(transContainer);

  // We collect all offer numbers
  const allSentences = new Set([
    ...origMap.keys(),
    ...transMap.keys()
  ]);

  allSentences.forEach(num => {
    const origEntry = origMap.get(num) || { label: null, windows: [] };
    const trEntry   = transMap.get(num)  || { label: null, windows: [] };
    const maxCnt = Math.max(origEntry.windows.length, trEntry.windows.length);

    // we fill up to maxCnt with empty windows
    function pad(entry, container) {
      // where to insert: immediately after the last window of the current sentence
      let ref = null;
      if (entry.windows.length) {
        ref = entry.windows[entry.windows.length - 1].nextSibling;
      } else if (entry.label) {
        ref = entry.label.nextSibling;
      }
      for (let i = entry.windows.length; i < maxCnt; i++) {
        const emptyWin = document.createElement('div');
        emptyWin.className = 'window empty-window';
        emptyWin.style.width = width * charWidth + 8 + 'px';
        emptyWin.style.height = height * charH + 8 + 'px';
        container.insertBefore(emptyWin, ref);
      }
    }

    pad(origEntry, origContainer);
    pad(trEntry,   transContainer);
  });
}

let isSyncingScroll = false;
outputOriginal.addEventListener('scroll', syncScroll);
outputTranslated.addEventListener('scroll', syncScroll);

document.getElementById('renderBtn').addEventListener('click', render);

['inputScript', 'translatedScript', 
'presetSizeOriginal', 'presetSizeTranslated', 
'widthCharsOriginal', 'heightLinesOriginal', 'charWidthOriginal', 
'widthCharsTranslated', 'heightLinesTranslated', 'charWidthTranslated', 
'charHeight', 'charFont', 'autoAlign', 'autoRender', 'keywordDictOriginal', 'keywordDictTranslated']
  .forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
      if (document.getElementById('autoRender').checked) render();
    });
  });

render();

divider.addEventListener('mousedown', e => {
  isDragging = true;
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none'; // Disable text selection
});

divider.addEventListener('mouseup', e => {
  if (isDragging) {
    isDragging = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = ''; // Revert selection back
  }
});


</script>
</body>
</html>
